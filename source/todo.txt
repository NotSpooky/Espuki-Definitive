Ok so, the following is what we want to do:

TypedFunction : Type [] inputs, Type returnType

TypedSymbol : Type type Symbol symbol

To create typed symbols there exists an intrinsic rule:
  'Typed 'symbol Type Symbol -> TypedSymbol

Which just creates it.

RTTypedFunction : RTValue (typedFunctionType, TypedFunction)

To create RTTypedFunctions, there exists an intrinsic rule such as:
  (Symbol | TypedSymbol) [] Graph : RTTypedFunctions

Which does:
  rArgs [0] -> ruleToAddArgs;
  rArgs [1] -> codeGraph;
  ruleToAddArgs enumerate.filter {val is TypedSymbol} -> inputWithPositions : TypedSymbol val, UI32 index
  compile codeGraph _ -> executableGraph, outputType
  ruleScope addRule ruleToAddArgs outputType ((Symbol | RTValue [] vals) {
    vals.indexed (inputWithPositions map {index})
    executableGraph execute _ // Return this
  })


Alright, so we can add functions from an array of sumtypes and a graph.
We then need to be able to:

1) Create sumtypes:
While the syntax below works for our use-case. A type must be created for a sumtype.
It must be searchable and created dynamically.

So it makes sense to introduce parametrized types.
ParametrizedType :
  // Provides memoization, and prevents multiple ids for types created
  Type [RTValue []] instances
  , TypedSymbol [] dataPerInstance
  , (Type thisType, RTValue [] pTParams) -> Rule [] rulesCreated

// TODO: CHECK THIS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

When instancing a ParametrizedType, a rule is created:
'ParametrizedType Any [] -> Type

Which does:
  if rArgs [1] in rArgs [0].instances:
    rArgs [0].instances [rArgs [1]]
  else:
    Type (mangledName) -> newT
    rArgs [0] instances [rArgs [1]] = newT
    rArgs [0] rulesCreated newT rArgs [1] -> newRules
    newRules each {
      ruleScope add _
    }
    newT


Note that we want to be able to do:
  SumType [I32, F32] -> I32OrF32
  I32OrF32 5 -> instance

The intuitive way of implementing this is making the rule:
  Type Type [] -> Type

However, that interferes with any other rule of the same shape.
Pattern matching is needed for this (alternatives were discarded)

This would extend the RuleTree to allow adding rules of (Symbol | Type | RTValue)
Then, when matching, the RTValues would have priority.
This is overall a nice feature to have.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Rules created by SumType:
  'SumType Type [] -> Type
The generated type will be called TypeInstance
  'TypeInstance Type1 -> TypeInstance
  'TypeInstance Type2 -> TypeInstance
  ...
  'TypeInstance is RTValue (Type1) -> Bool
  'TypeInstance is RTValue (Type2) -> Bool
  ...
  // Do note that the above can be implemented without pattern matching with:
  'TypeInstance is Value -> Bool
  // And erroring on non-member types.
  'TypeInstance get RTValue (Type1) -> Type1
  'TypeInstance get RTValue (Type2) -> Type2
  ...
  // This is also possible to do without pattern matching, the return type
  // cannot be specified beforehand though.
Ideally, a visit function would also be there:
  sumTypeInstance 'visit ((Type1 -> A) | (Type2 -> A) ...) [] : A
  // But this requires keeping track of A.


Which does:
  if instanceType == type_:
    true
  else:
    enforce (canFind type_ in validTypes)
    false

And the rule:
  sumTypeInstance 'get Type

Which does:
  enforce (sumTypeInstanceInstance is type_)
  sumTypeInstanceInstance value get

2) Create arrays:
An array is just
There are 3 possible cases for array-like sequences:
  If the sequence contains a single type, it makes sense to model it as an array.

    openingSquareBracket comma separated RTValues closingBracket

  If the sequence contains multiple types from a known set it makes sense to model it as
    an array of a sumtype.

    openingSquareBracket verticalBar comma separated RTValues closingBracket

  If the sequence contains multiple arbitrary types, it makes sense to model it
    as a tuple.

    openingParenthesis comma separated RTValues closingParenthesis

3) Create graphs:
A graph is just an Expression [] for the textual representation.
So the lexer/parser must be able to understand
  openingBracket Expression * closingBracket
  that can span multiple lines
  And put its contents in an RTValue of type (rawExpressionsType, expressions)

4) Not strictly needed, Symbol token:

  'identifier
